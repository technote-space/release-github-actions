"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const index_1 = require("./index");
const utils_1 = require("./utils");
const context_helper_1 = require("./context-helper");
/**
 * Git Helper
 */
class GitHelper {
    /**
     * @param {Logger} logger logger
     * @param {object} options options
     * @param {number|undefined} options.depth depth
     * @param {function|undefined} options.filter filter
     */
    constructor(logger, options) {
        var _a;
        this.logger = logger;
        this.origin = undefined;
        this.quietIfNotOrigin = true;
        /**
         * @return {boolean} should suppress error
         */
        this.shouldSuppressError = () => !utils_1.isCommandDebug();
        /**
         * @return {boolean} is quiet?
         */
        this.isQuiet = () => !utils_1.isOutputDebug() && (!this.origin || this.quietIfNotOrigin);
        /**
         * @param {string} workDir work dir
         * @param {string[]} commands commands
         * @return {Promise<{}[]>} void
         */
        this.runCommand = async (workDir, commands) => {
            const result = [];
            try {
                for (const command of (Array.isArray(commands) ? commands : [commands])) {
                    if (typeof command === 'string') {
                        const output = (await this.command.execAsync({ command, cwd: workDir }));
                        result.push({
                            command: output.command,
                            stdout: utils_1.split(output.stdout),
                            stderr: utils_1.split(output.stderr),
                        });
                    }
                    else {
                        const output = (await this.command.execAsync({ cwd: workDir, ...command }));
                        result.push({
                            command: output.command,
                            stdout: utils_1.split(output.stdout),
                            stderr: utils_1.split(output.stderr),
                        });
                    }
                }
                return result;
            }
            catch (error) {
                console.log();
                console.log(error);
                throw error;
            }
        };
        /**
         * @param {string} workDir work dir
         * @param {boolean} refresh refresh?
         * @return {Promise<void>} void
         */
        this.initialize = async (workDir, refresh = true) => {
            if (utils_1.isCloned(workDir) && !refresh) {
                return;
            }
            if (fs_1.default.existsSync(workDir)) {
                await this.runCommand(workDir, { command: 'rm', args: ['-rdf', workDir] });
            }
            fs_1.default.mkdirSync(workDir, { recursive: true });
            await this.runCommand(workDir, { command: 'git init', args: ['.'] });
        };
        /**
         * @param {string|boolean} origin origin
         * @param {boolean} quiet quiet?
         */
        this.useOrigin = (origin, quiet) => {
            this.origin = typeof origin === 'boolean' ? (origin ? 'origin' : undefined) : origin;
            if (quiet !== undefined) {
                this.quietIfNotOrigin = quiet;
            }
        };
        /**
         * @return {string} origin name
         */
        this.getRemoteName = () => { var _a; return (_a = this.origin) !== null && _a !== void 0 ? _a : 'origin'; };
        /**
         * @param {Context} context context
         * @return {string} origin
         */
        this.getRemote = (context) => { var _a; return (_a = this.origin) !== null && _a !== void 0 ? _a : context_helper_1.getGitUrlWithToken(context, this.token); };
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.addOrigin = async (workDir, context) => {
            await this.initialize(workDir, false);
            await this.runCommand(workDir, {
                command: 'git remote add',
                args: [this.getRemoteName(), context_helper_1.getGitUrlWithToken(context, this.token)],
                stderrToStdout: this.isQuiet(),
                altCommand: `git remote add ${this.getRemoteName()}`,
                suppressError: this.shouldSuppressError(),
            });
        };
        /**
         * @param {string} workDir work dir
         * @return {Promise<string>} branch name
         */
        this.getCurrentBranchName = async (workDir) => {
            var _a, _b;
            if (!utils_1.isCloned(workDir)) {
                return '';
            }
            return (_b = (_a = (await this.runCommand(workDir, {
                command: 'git rev-parse',
                args: ['--abbrev-ref', 'HEAD'],
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            }))[0].stdout[0]) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : '';
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.cloneBranch = async (workDir, branch, context) => {
            await this.runCommand(workDir, {
                command: 'git clone',
                args: [`--branch=${branch}`, this.cloneDepth, this.getRemote(context), '.'],
                stderrToStdout: this.isQuiet(),
                altCommand: `git clone --branch=${branch}`,
                suppressError: this.shouldSuppressError(),
            });
        };
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clonePR = async (workDir, context) => {
            await this.runCommand(workDir, [
                {
                    command: 'git clone',
                    args: [this.cloneDepth, this.getRemote(context), '.'],
                    stderrToStdout: this.isQuiet(),
                    altCommand: 'git clone',
                    suppressError: this.shouldSuppressError(),
                },
                {
                    command: 'git fetch',
                    args: [this.getRemote(context), `+${context.ref}`],
                    quiet: this.isQuiet(),
                    altCommand: `git fetch ${this.getRemoteName()} ${context.ref}`,
                    stderrToStdout: true,
                },
                {
                    command: 'git checkout',
                    args: ['-qf', 'FETCH_HEAD'],
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.clone = async (workDir, context) => {
            if (utils_1.isCloned(workDir)) {
                return;
            }
            if (utils_1.isBranch(context)) {
                await this.cloneBranch(workDir, utils_1.getBranch(context), context);
            }
            else if (utils_1.isPrRef(context)) {
                await this.clonePR(workDir, context);
            }
            else {
                await this.checkout(workDir, context);
            }
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.gitInit = async (workDir, branch) => {
            await this.initialize(workDir);
            await this.runCommand(workDir, { command: 'git checkout', args: ['--orphan', branch], stderrToStdout: true });
        };
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @param {string[]} options options
         * @param {string[]} refspec refspec
         * @return {Promise<void>} void
         */
        this.fetchOrigin = async (workDir, context, options, refspec) => {
            await this.addOrigin(workDir, context);
            await this.runCommand(workDir, {
                command: 'git fetch',
                args: [
                    ...(options !== null && options !== void 0 ? options : []),
                    this.getRemoteName(),
                    ...(refspec !== null && refspec !== void 0 ? refspec : []),
                ],
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            });
        };
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.checkout = async (workDir, context) => {
            await this.fetchOrigin(workDir, context, ['--no-tags'], [utils_1.getRefspec(context)]);
            await this.runCommand(workDir, [
                {
                    command: 'git checkout',
                    args: ['-qf', context.sha],
                    stderrToStdout: true,
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.fetchBranch = async (workDir, branch, context) => {
            const branchName = utils_1.getBranch(branch, false);
            await this.runCommand(workDir, {
                command: 'git fetch',
                args: ['--prune', '--no-tags', '--no-recurse-submodules', this.cloneDepth, this.getRemote(context), `+refs/heads/${branchName}:refs/remotes/${this.getRemoteName()}/${branchName}`],
                altCommand: `git fetch --prune --no-tags --no-recurse-submodules${this.cloneDepth} ${this.getRemoteName()} +refs/heads/${branchName}:refs/remotes/${this.getRemoteName()}/${branchName}`,
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            });
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.createBranch = async (workDir, branch) => {
            await this.runCommand(workDir, { command: 'git checkout', args: ['-b', branch], stderrToStdout: true });
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @return {Promise<void>} void
         */
        this.switchBranch = async (workDir, branch) => {
            await this.runCommand(workDir, {
                command: 'git checkout',
                args: ['-b', branch, `${this.getRemoteName()}/${branch}`],
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            });
            await this.runCommand(workDir, {
                command: 'git checkout',
                args: [branch],
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            });
        };
        /**
         * @param {string} workDir work dir
         * @param {string} name name
         * @param {string} email email
         * @return {Promise<void>} void
         */
        this.config = async (workDir, name, email) => {
            await this.runCommand(workDir, [
                {
                    command: 'git config',
                    args: ['user.name', name],
                },
                {
                    command: 'git config',
                    args: ['user.email', email],
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @return {Promise<string[]>} diff
         */
        this.getDiff = async (workDir) => (await this.runCommand(workDir, {
            command: 'git status',
            args: ['--short', '-uno'],
            suppressOutput: true,
        }))[0].stdout.filter(line => line.match(/^[MDA]\s+/)).filter(this.filter).map(line => line.replace(/^[MDA]\s+/, ''));
        /**
         * @param {string} workDir work dir
         * @param {string} baseRef base ref
         * @param {string} compareRef compare ref
         * @param {string} diffFilter diff filter
         * @param {string} dot dot
         * @return {Promise<string[]>} diff
         */
        this.getRefDiff = async (workDir, baseRef, compareRef, diffFilter, dot) => {
            const toDiffRef = (ref) => 'HEAD' === ref ? 'HEAD' : (utils_1.isPrRef(ref) ? ref.replace(/^refs\//, '') : `${this.getRemoteName()}/${utils_1.getBranch(ref, false)}`);
            return (await this.runCommand(workDir, {
                command: 'git diff',
                args: [`${toDiffRef(baseRef)}${dot !== null && dot !== void 0 ? dot : '...'}${toDiffRef(compareRef)}`, '--name-only', diffFilter ? `--diff-filter=${diffFilter}` : ''],
                suppressOutput: true,
            }))[0].stdout.filter(item => !!item.trim());
        };
        /**
         * @param {string} workDir work dir
         * @return {Promise<boolean>} result
         */
        this.checkDiff = async (workDir) => !!(await this.getDiff(workDir)).length;
        /**
         * @param {string} workDir work dir
         * @param {string} message message
         * @param {object} options options
         */
        this.commit = async (workDir, message, options) => {
            await this.runCommand(workDir, { command: 'git add', args: ['--all'] });
            if (!(options === null || options === void 0 ? void 0 : options.allowEmpty) && !await this.checkDiff(workDir)) {
                this.logger.info('There is no diff.');
                return false;
            }
            await this.makeCommit(workDir, message, options);
            return true;
        };
        /**
         * @param {string} workDir work dir
         * @param {string} message message
         * @param {object} options options
         */
        this.makeCommit = async (workDir, message, options) => {
            var _a, _b, _c;
            const count = (_a = options === null || options === void 0 ? void 0 : options.count) !== null && _a !== void 0 ? _a : 10; // eslint-disable-line no-magic-numbers
            const allowEmpty = (_b = options === null || options === void 0 ? void 0 : options.allowEmpty) !== null && _b !== void 0 ? _b : false;
            const args = (_c = options === null || options === void 0 ? void 0 : options.args) !== null && _c !== void 0 ? _c : [];
            await this.runCommand(workDir, [
                {
                    command: 'git commit',
                    args: [allowEmpty ? '--allow-empty' : '', ...args, '-qm', message],
                },
                {
                    command: 'git show',
                    args: [`--stat-count=${count}`, 'HEAD'],
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @param {object} options options
         * @return {Promise<string[]>} tags
         */
        this.getTags = async (workDir, options) => (await this.runCommand(workDir, {
            command: 'git tag',
            suppressOutput: (options === null || options === void 0 ? void 0 : options.suppressOutput) || (options === null || options === void 0 ? void 0 : options.quiet),
            altCommand: (options === null || options === void 0 ? void 0 : options.quiet) ? '' : undefined,
        }))[0].stdout;
        /**
         * @param {string} workDir work dir
         * @param {Context} context context
         * @param {number} splitSize split size
         * @return {Promise<void>} void
         * @see https://qiita.com/ngyuki/items/ca7bed067d7e538fd0cd
         */
        this.fetchTags = async (workDir, context, splitSize = 20) => {
            await this.runCommand(workDir, [
                ...utils_1.arrayChunk(await this.getTags(workDir, { quiet: true }), splitSize).map(tags => ({
                    command: 'git tag',
                    args: ['-d', ...tags],
                    quiet: true,
                })),
                {
                    command: 'git fetch',
                    args: [this.getRemote(context), '--tags'],
                    quiet: this.isQuiet(),
                    altCommand: `git fetch ${this.getRemoteName()} --tags`,
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @param {Context} context context
         * @param {number} splitSize split size
         * @return {Promise<void>} void
         */
        this.deleteTag = async (workDir, tags, context, splitSize = 20) => {
            const getTagRef = (tag) => /^(refs\/)?tags\//.test(tag) ? tag : `tags/${tag}`;
            await this.runCommand(workDir, utils_1.arrayChunk((typeof tags === 'string' ? [tags] : tags).map(getTagRef), splitSize).map(tags => ({
                command: 'git push',
                args: [this.getRemote(context), '--delete', ...tags],
                stderrToStdout: this.isQuiet(),
                altCommand: `git push ${this.getRemoteName()} --delete ${tags.join(' ')}`,
                suppressError: this.shouldSuppressError(),
            })));
            await this.deleteLocalTag(workDir, tags, splitSize);
        };
        /**
         * @param {string} workDir work dir
         * @param {string} newTag new tag
         * @param {string} fromTag from tag
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.copyTag = async (workDir, newTag, fromTag, context) => {
            await this.deleteTag(workDir, newTag, context);
            await this.runCommand(workDir, [
                {
                    command: 'git tag',
                    args: [newTag, fromTag],
                },
                {
                    command: 'git push',
                    args: [this.getRemote(context), `refs/tags/${newTag}`],
                    stderrToStdout: this.isQuiet(),
                    altCommand: `git push ${this.getRemoteName()} refs/tags/${newTag}`,
                },
            ]);
        };
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @param {number} splitSize split size
         * @return {Promise<void>} void
         */
        this.deleteLocalTag = async (workDir, tags, splitSize = 20) => {
            const getTag = (tag) => tag.replace(/^(refs\/)?tags\//, '');
            await this.runCommand(workDir, utils_1.arrayChunk((typeof tags === 'string' ? [tags] : tags).map(getTag), splitSize).map(tags => ({
                command: 'git tag',
                args: ['-d', ...tags],
                suppressError: this.shouldSuppressError(),
                stderrToStdout: true,
            })));
        };
        /**
         * @param {string} workDir work dir
         * @param {string|string[]} tags tags
         * @return {Promise<void>} void
         */
        this.addLocalTag = async (workDir, tags) => {
            if ('string' === typeof tags) {
                await this.runCommand(workDir, { command: 'git tag', args: [tags] });
            }
            else {
                for (const tag of tags) {
                    await this.addLocalTag(workDir, tag);
                }
            }
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @param {object} options options
         * @return {Promise<void>} void
         */
        this.push = async (workDir, branch, context, options) => {
            const args = [];
            if (options === null || options === void 0 ? void 0 : options.withTag) {
                args.push('--tags');
            }
            if (options === null || options === void 0 ? void 0 : options.force) {
                args.push('--force');
            }
            if (options === null || options === void 0 ? void 0 : options.args) {
                args.push(...options.args);
            }
            await this.runCommand(workDir, {
                command: 'git push',
                args: args.concat([this.getRemote(context), `${branch}:refs/heads/${branch}`]),
                stderrToStdout: this.isQuiet(),
                altCommand: `git push ${args.concat([this.getRemoteName(), `${branch}:refs/heads/${branch}`]).join(' ')}`,
                suppressError: this.shouldSuppressError(),
            });
        };
        /**
         * @param {string} workDir work dir
         * @param {string} branch branch
         * @param {Context} context context
         * @return {Promise<void>} void
         */
        this.forcePush = async (workDir, branch, context) => this.push(workDir, branch, context, { force: true });
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getLastTag = async (workDir) => {
            var _a, _b;
            if (!utils_1.isCloned(workDir)) {
                throw new Error('Not a git repository');
            }
            return 'v' + ((_b = (_a = (await this.getTags(workDir)).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).sort(utils_1.versionCompare).reverse()[0]) === null || _a === void 0 ? void 0 : _a.replace(/^v/, '')) !== null && _b !== void 0 ? _b : '0.0.0');
        };
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getNewPatchVersion = async (workDir) => utils_1.generateNewPatchVersion(await this.getLastTag(workDir));
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getNewMinorVersion = async (workDir) => utils_1.generateNewMinorVersion(await this.getLastTag(workDir));
        /**
         * @param {string} workDir work dir
         * @return {string} tag
         */
        this.getNewMajorVersion = async (workDir) => utils_1.generateNewMajorVersion(await this.getLastTag(workDir));
        this.command = new index_1.Command(logger);
        this.token = (_a = options === null || options === void 0 ? void 0 : options.token) !== null && _a !== void 0 ? _a : utils_1.getAccessToken(true);
        if (options && options.depth) {
            this.cloneDepth = options.depth > 0 ? `--depth=${options.depth}` : ''; // eslint-disable-line no-magic-numbers
        }
        else {
            this.cloneDepth = '--depth=3';
        }
        if (options && options.filter) {
            this.filter = options.filter;
        }
        else {
            this.filter = (line) => !!line.trim();
        }
    }
}
exports.default = GitHelper;
