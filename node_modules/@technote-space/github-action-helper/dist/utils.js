"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceVariables = exports.mask = exports.versionCompare = exports.arrayChunk = exports.generateNewMajorVersion = exports.generateNewMinorVersion = exports.generateNewPatchVersion = exports.generateNewVersion = exports.replaceAll = exports.useNpm = exports.sleep = exports.getArrayInput = exports.split = exports.getWorkspace = exports.uniqueArray = exports.getBoolValue = exports.getSuffixRegExp = exports.getPrefixRegExp = exports.getRegExp = exports.escapeRegExp = exports.getActor = exports.getOctokit = exports.getAccessToken = exports.getRefspec = exports.getLocalRefspec = exports.getRemoteRefspec = exports.getTag = exports.trimRef = exports.normalizeRef = exports.getPrBranch = exports.getBranch = exports.getRefForUpdate = exports.getPrHeadRef = exports.getPrMergeRef = exports.isPrRef = exports.isRemoteBranch = exports.isTagRef = exports.isBranch = exports.isRef = exports.isSemanticVersioningTagName = exports.isValidSemanticVersioning = exports.normalizeVersion = exports.parseVersion = exports.isCloned = exports.getBuildInfo = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("@actions/core");
const github_1 = require("@actions/github");
const getRef = (ref) => typeof ref === 'string' ? ref : ref.ref;
exports.getBuildInfo = (filepath) => {
    if (!fs_1.default.existsSync(filepath)) {
        return false;
    }
    try {
        return JSON.parse(fs_1.default.readFileSync(filepath, 'utf8'));
    }
    catch (_a) {
        return false;
    }
};
exports.isCloned = (workDir) => fs_1.default.existsSync(path_1.default.resolve(workDir, '.git'));
exports.parseVersion = (version, options) => {
    var _a, _b, _c, _d, _e;
    // https://semver.org/spec/v2.0.0.html
    const regex = (options === null || options === void 0 ? void 0 : options.strict) ?
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*)){2})(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/ :
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*))*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    const matches = version.trim().replace(/^[=v]+/, '').match(regex);
    if (!matches) {
        return undefined;
    }
    const fragments = exports.split(matches[1], '.');
    // eslint-disable-next-line no-magic-numbers
    const length = (options === null || options === void 0 ? void 0 : options.slice) && options.slice < 0 ? ((_a = options.length) !== null && _a !== void 0 ? _a : 3) : ((_c = (_b = options === null || options === void 0 ? void 0 : options.slice) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.length) !== null && _c !== void 0 ? _c : 3);
    // eslint-disable-next-line no-magic-numbers
    while ((options === null || options === void 0 ? void 0 : options.fill) !== false && fragments.length < length) {
        fragments.push('0');
    }
    return {
        // eslint-disable-next-line no-magic-numbers
        core: ((options === null || options === void 0 ? void 0 : options.cut) === false ? fragments : fragments.slice(0, (_e = (_d = options === null || options === void 0 ? void 0 : options.slice) !== null && _d !== void 0 ? _d : options === null || options === void 0 ? void 0 : options.length) !== null && _e !== void 0 ? _e : 3)).join('.'),
        preRelease: matches[5],
        build: matches[6],
        fragments,
    };
};
exports.normalizeVersion = (version, options) => {
    const parsed = exports.parseVersion(version, options);
    if (!parsed) {
        return options === null || options === void 0 ? void 0 : options.fallback;
    }
    if (options === null || options === void 0 ? void 0 : options.onlyCore) {
        return parsed.core;
    }
    return parsed.core + (parsed.preRelease ? `-${parsed.preRelease}` : '') + (parsed.build ? `+${parsed.build}` : '');
};
exports.isValidSemanticVersioning = (version, strict) => exports.parseVersion(version, { strict }) !== undefined;
/* istanbul ignore next */
/*
 * @deprecated Use isValidSemanticVersioning
 */
exports.isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
exports.isRef = (ref) => /^refs\//.test(getRef(ref));
exports.isBranch = (ref) => /^refs\/heads\//.test(getRef(ref));
exports.isTagRef = (ref) => /^refs\/tags\//.test(getRef(ref));
exports.isRemoteBranch = (ref) => /^refs\/remotes\/origin\//.test(getRef(ref));
exports.isPrRef = (ref) => /^refs\/pull\/\d+\/(merge|head)$/.test(getRef(ref));
exports.getPrMergeRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
exports.getPrHeadRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
exports.getRefForUpdate = (ref) => getRef(ref).replace(/^refs\//, '');
exports.getBranch = (ref, defaultIsEmpty = true) => exports.isBranch(ref) ?
    getRef(ref).replace(/^refs\/heads\//, '') :
    (exports.isRemoteBranch(ref) ? getRef(ref).replace(/^refs\/remotes\/origin\//, '') :
        (defaultIsEmpty ? '' : exports.getRefForUpdate(ref)));
exports.getPrBranch = (context) => { var _a, _b; return (_b = (_a = context.payload.pull_request) === null || _a === void 0 ? void 0 : _a.head.ref) !== null && _b !== void 0 ? _b : ''; };
exports.normalizeRef = (ref) => exports.isRef(ref) ? getRef(ref) : `refs/heads/${getRef(ref)}`;
exports.trimRef = (ref) => getRef(ref).replace(/^refs\/(heads|tags|pull)\//, '');
exports.getTag = (ref) => exports.isTagRef(ref) ? exports.trimRef(ref) : '';
const saveTarget = (ref, origin) => exports.isTagRef(ref) ? 'tags' : exports.isPrRef(ref) ? `${origin}/pull` : origin;
// e.g.
//  refs/heads/master
//  refs/pull/123/merge
//  refs/tags/v1.2.3
exports.getRemoteRefspec = (ref) => exports.normalizeRef(ref);
// e.g.
//  origin/master
//  origin/pull/123/merge
//  tags/v1.2.3
exports.getLocalRefspec = (ref, origin = 'origin') => `${saveTarget(ref, origin)}/${exports.trimRef(ref)}`;
// e.g.
//  refs/heads/master:refs/remotes/origin/master
//  refs/pull/123/merge:refs/pull/123/merge
//  refs/tags/v1.2.3:refs/tags/v1.2.3
exports.getRefspec = (ref, origin = 'origin') => `${exports.getRemoteRefspec(ref)}:refs/${exports.getLocalRefspec(ref, `remotes/${origin}`)}`;
exports.getAccessToken = (required) => core_1.getInput('GITHUB_TOKEN', { required });
exports.getOctokit = (token) => github_1.getOctokit(token !== null && token !== void 0 ? token : exports.getAccessToken(true), {});
exports.getActor = () => process.env.GITHUB_ACTOR || '';
exports.escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports.getRegExp = (value) => new RegExp(exports.escapeRegExp(value));
exports.getPrefixRegExp = (value, flags = '') => new RegExp('^' + exports.escapeRegExp(value), flags);
exports.getSuffixRegExp = (value, flags = '') => new RegExp(exports.escapeRegExp(value) + '$', flags);
exports.getBoolValue = (input) => !['false', '0', '', 'no', 'n'].includes(input.trim().toLowerCase());
exports.uniqueArray = (array) => [...new Set(array)];
exports.getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
exports.split = (value, separator = /\r?\n/, limit) => value.length ? value.split(separator, limit) : [];
exports.getArrayInput = (name, required = false, separator = ',', unique = true) => {
    const arrayInput = core_1.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []);
    return unique ? exports.uniqueArray(arrayInput) : arrayInput;
};
exports.sleep = (millisecond) => __awaiter(void 0, void 0, void 0, function* () { return new Promise(resolve => setTimeout(resolve, millisecond)); });
exports.useNpm = (workDir, pkgManager = '') => 'npm' === pkgManager ||
    ('yarn' !== pkgManager && (fs_1.default.existsSync(path_1.default.resolve(workDir, 'package-lock.json')) ||
        !fs_1.default.existsSync(path_1.default.resolve(workDir, 'yarn.lock'))));
exports.replaceAll = (string, key, value) => string.split(key).join(value);
exports.generateNewVersion = (lastTag, position) => {
    const parsed = exports.parseVersion(lastTag);
    if (!parsed) {
        throw new Error('Invalid versioning');
    }
    const target = Math.max(Math.min(position !== null && position !== void 0 ? position : 2, 2), 0); // eslint-disable-line no-magic-numbers
    parsed.fragments[target] = (Number(parsed.fragments[target]) + 1).toString(); // eslint-disable-line no-magic-numbers
    [...Array(2 - target).keys()].forEach(key => parsed.fragments[2 - key] = '0'); // eslint-disable-line no-magic-numbers
    return 'v' + parsed.fragments.slice(0, 3).join('.'); // eslint-disable-line no-magic-numbers
};
exports.generateNewPatchVersion = (lastTag) => exports.generateNewVersion(lastTag);
exports.generateNewMinorVersion = (lastTag) => exports.generateNewVersion(lastTag, 1); // eslint-disable-line no-magic-numbers
exports.generateNewMajorVersion = (lastTag) => exports.generateNewVersion(lastTag, 0); // eslint-disable-line no-magic-numbers
// eslint-disable-next-line no-magic-numbers
exports.arrayChunk = (array, size = 100) => {
    const result = [];
    const length = array.length;
    for (let index = 0; index < length; index += size) {
        result.push(array.slice(index, index + size));
    }
    return result;
};
exports.versionCompare = (version1, version2, checkDifferentLevel = true) => {
    const splitVersion = (version) => version.split('.').map(item => Number(item));
    // eslint-disable-next-line no-magic-numbers
    const compare = (version1, version2, num = 0) => {
        var _a, _b;
        if (version1.length <= num && version2.length <= num) {
            // eslint-disable-next-line no-magic-numbers
            return checkDifferentLevel ? Math.sign(version1.length - version2.length) : 0;
        }
        // eslint-disable-next-line no-magic-numbers
        const val1 = (_a = version1[num]) !== null && _a !== void 0 ? _a : (checkDifferentLevel ? 0 : version2[num]);
        // eslint-disable-next-line no-magic-numbers
        const val2 = (_b = version2[num]) !== null && _b !== void 0 ? _b : (checkDifferentLevel ? 0 : version1[num]);
        return val1 === val2 ? compare(version1, version2, ++num) : Math.sign(val1 - val2);
    };
    return compare(splitVersion(version1.replace(/^v/, '')), splitVersion(version2.replace(/^v/, '')));
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
exports.mask = (value, target = 'token') => {
    Object.keys(value).forEach(key => {
        if (value[key] && typeof value[key] === 'object') {
            value[key] = exports.mask(value[key], target);
        }
        else if (target === key) {
            value[key] = '***';
        }
    });
    return value;
};
exports.replaceVariables = (string, variables) => __awaiter(void 0, void 0, void 0, function* () {
    let replaced = string;
    for (const variable of variables) {
        if (exports.getRegExp(`\${${variable.key}}`).test(replaced)) {
            if (typeof variable.replace === 'string') {
                replaced = exports.replaceAll(replaced, `\${${variable.key}}`, variable.replace);
            }
            else {
                replaced = exports.replaceAll(replaced, `\${${variable.key}}`, yield variable.replace());
            }
        }
    }
    return replaced;
});
